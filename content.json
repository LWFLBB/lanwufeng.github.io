{"meta":{"title":"Mr_lan's Blog","subtitle":null,"description":null,"author":"Mr_lan","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"","slug":"cocoapods install 报相关 Error 解决方案 ","date":"2018-08-07T10:38:23.521Z","updated":"2018-08-07T10:55:03.018Z","comments":true,"path":"2018/08/07/cocoapods install 报相关 Error 解决方案 /","link":"","permalink":"http://yoursite.com/2018/08/07/cocoapods install 报相关 Error 解决方案 /","excerpt":"cocoapods install 报相关 Error 解决方案 pod install 出现LoadError - cannot load such file – nanaimo 解决方案： 1234567891011//卸载 cocoapodsgem uninstall cocoapods gem uninstall -i /Users/XXX/.rvm/gems/ruby-2.2.4@global cocoapods//卸载 nanaimogem uninstall nanaimogem uninstall -i /Users/XXX/.rvm/gems/ruby-2.2.4@global nanaimo //安装更新cocoapodsgem install cocoapods","text":"cocoapods install 报相关 Error 解决方案 pod install 出现LoadError - cannot load such file – nanaimo 解决方案： 1234567891011//卸载 cocoapodsgem uninstall cocoapods gem uninstall -i /Users/XXX/.rvm/gems/ruby-2.2.4@global cocoapods//卸载 nanaimogem uninstall nanaimogem uninstall -i /Users/XXX/.rvm/gems/ruby-2.2.4@global nanaimo //安装更新cocoapodsgem install cocoapods 出现LoadError - cannot load such file – macho 解决方案 12345//终端打开cd /Users/weiyuxiang/.rvm/gems/ruby-2.2.4/gems/cocoapods-1.5.3/lib/cocoapods/sandbox//打开 file_accessor.rb 文件，修改autoload :MachO, &apos;macho&apos; 修改成 require &apos;macho&apos;","categories":[],"tags":[]},{"title":"ios开发小技巧合集","slug":"ios开发小技巧合集","date":"2018-07-15T05:34:13.000Z","updated":"2018-09-08T03:24:49.268Z","comments":true,"path":"2018/07/15/ios开发小技巧合集/","link":"","permalink":"http://yoursite.com/2018/07/15/ios开发小技巧合集/","excerpt":"本文主要记录日常工作中积累的一些iOS小技巧 禁止手机睡眠 1[UIApplication sharedApplication].idleTimerDisabled = YES; 隐藏某行cell 12345678910111213- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath&#123;// 如果是你需要隐藏的那一行，返回高度为0 if(indexPath.row == YouWantToHideRow)&#123; return 0; &#125; return 44;&#125;// 然后再你需要隐藏cell的时候调用[self.tableView beginUpdates];[self.tableView endUpdates];","text":"本文主要记录日常工作中积累的一些iOS小技巧 禁止手机睡眠 1[UIApplication sharedApplication].idleTimerDisabled = YES; 隐藏某行cell 12345678910111213- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath&#123;// 如果是你需要隐藏的那一行，返回高度为0 if(indexPath.row == YouWantToHideRow)&#123; return 0; &#125; return 44;&#125;// 然后再你需要隐藏cell的时候调用[self.tableView beginUpdates];[self.tableView endUpdates]; SDWebImage 加载大量高清图片时内存暴增 解决方案：关闭SD加载高清大图时的解压缩 12345678910111213141516171819202122232425262728293031323334static BOOL SDImageCacheOldShouldDecompressImages = YES; static BOOL SDImagedownloderOldShouldDecompressImages = YES; - (void)viewDidLoad &#123; [super viewDidLoad]; // 关闭SD加载高清大图时的解压缩 SDImageCache *canche = [SDImageCache sharedImageCache]; SDImageCacheOldShouldDecompressImages = canche.shouldDecompressImages; canche.shouldDecompressImages = NO; SDWebImageDownloader *downloder = [SDWebImageDownloader sharedDownloader]; SDImagedownloderOldShouldDecompressImages = downloder.shouldDecompressImages; downloder.shouldDecompressImages = NO; &#125; -(void)dealloc &#123; SDImageCache *canche = [SDImageCache sharedImageCache]; canche.shouldDecompressImages = SDImageCacheOldShouldDecompressImages; SDWebImageDownloader *downloder = [SDWebImageDownloader sharedDownloader]; downloder.shouldDecompressImages = SDImagedownloderOldShouldDecompressImages; &#125; SDWebImage本地缓存有时候会害人。如果之前缓存过一张图片，即使下次服务器换了这张图片，但是图片url没换，用SDWebimage下载下来的还是以前那张，所以遇到这种问题，不要先去怼服务器，清空下缓存再试就好了。 禁用button高亮 123button.adjustsImageWhenHighlighted = NO;或者在创建的时候UIButton *button = [UIButton buttonWithType:UIButtonTypeCustom]; 动画切换window的根控制器 123456789[UIView transitionWithView:[UIApplication sharedApplication].keyWindow duration:.5f options:UIViewAnimationOptionTransitionCrossDissolve animations:^&#123; BOOL oldState = [UIView areAnimationsEnabled]; [UIView setAnimationsEnabled:NO]; [UIApplication sharedApplication].keyWindow.rootViewController = [[RootViewController alloc]init]; [UIView setAnimationsEnabled:oldState]; &#125; completion:^(BOOL finished) &#123; &#125;]; 去除数组中重复的对象 1NSArray *newArr = [oldArr valueForKeyPath:@&quot;@distinctUnionOfObjects.self&quot;]; 编译的时候遇到 no such file or directory: /users/apple/XXX 是因为编译的时候，在此路径下找不到这个文件，解决这个问题，首先是是要检查缺少的文件是不是在工程中，如果不在工程中，需要从本地拖进去，如果发现已经存在工程中了，或者拖进去还是报错，这时候需要去build phases中搜索这个文件，这时候很可能会搜出现两个相同的文件，这时候，有一个路径是正确的，删除另外一个即可。如果删除了还是不行，需要把两个都删掉，然后重新往工程里拖进这个文件即可 iOS8系统中，tableView最好实现下-tableView: heightForRowAtIndexPath:这个代理方法，要不然在iOS8中可能就会出现显示不全或者无法响应事件的问题 iOS8中实现侧滑功能的时候这个方法必须实现，要不然在iOS8中无法侧滑 1234// 必须写的方法，和editActionsForRowAtIndexPath配对使用，里面什么不写也行- (void)tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath &#123;&#125; 三个比较特殊的通知 12345NSSystemTimeZoneDidChangeNotification监听修改时间界面的两个按钮状态变化UIApplicationSignificantTimeChangeNotification 监听用户改变时间 （只要点击自动设置按钮就会调用）NSSystemClockDidChangeNotification 监听用户修改时间（时间不同才会调用） 获取不到UICollectionView指定cell的问题 12345678[self.collectionView layoutIfNeeded];//添加这句话就好 QTMResContinueEditeCell *cell = (QTMResContinueEditeCell *)[self.collectionView cellForItemAtIndexPath:[NSIndexPath indexPathForItem:_index inSection:0]];``` - 跳进app权限设置 // 跳进app设置if (UIApplicationOpenSettingsURLString != NULL) { UIApplication application = [UIApplication sharedApplication]; NSURL URL = [NSURL URLWithString:UIApplicationOpenSettingsURLString]; if ([application respondsToSelector:@selector(openURL:options:completionHandler:)]) { [application openURL:URL options:@{} completionHandler:nil]; } else { [application openURL:URL]; }} 12- 给一个view截图 (UIImage )cutImageWithView:(UIView )view{ UIGraphicsBeginImageContextWithOptions(view.frame.size, NO, 0); [view.layer renderInContext:UIGraphicsGetCurrentContext()]; UIImage *image = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return image;} 1234- 注意对象为nil的时候，调用此对象分类的方法不会执行- collectionView的内容小于其宽高的时候是不能滚动的，设置可以滚动： collectionView.alwaysBounceHorizontal = YES; collectionView.alwaysBounceVertical = YES; 12- 颜色转图片 (UIImage )imageWithColor:(UIColor )color { //描述一个矩形 CGRect rect = CGRectMake(0.0f, 0.0f, 1.0f, 1.0f); //开启图形上下文 UIGraphicsBeginImageContextWithOptions(rect.size, NO, 0); //获得图形上下文 CGContextRef ctx = UIGraphicsGetCurrentContext(); //使用color演示填充上下文 CGContextSetFillColorWithColor(ctx, [color CGColor]); //渲染上下文 CGContextFillRect(ctx, rect); UIImage *image = UIGraphicsGetImageFromCurrentImageContext(); //关闭图形上下文 UIGraphicsEndImageContext(); return image; } 123- view设置圆角 #define ViewBorderRadius(View, Radius, Width, Color)\\\\[View.layer setCornerRadius:(Radius)];\\[View.layer setMasksToBounds:YES];\\[View.layer setBorderWidth:(Width)];\\[View.layer setBorderColor:[Color CGColor]] // view圆角 12- view某个角度设置圆角 UIBezierPath maskPath = [UIBezierPath bezierPathWithRoundedRect:self.whiteView.bounds byRoundingCorners:UIRectCornerTopLeft | UIRectCornerTopRight cornerRadii:CGSizeMake(10, 10)]; CAShapeLayer maskLayer = [[CAShapeLayer alloc] init]; maskLayer.frame = self.whiteView.bounds; maskLayer.path = maskPath.CGPath; self.whiteView.layer.mask = maskLayer; ##指定了需要成为圆角的角该参数是UIRectCorner类型的，可选的值有： UIRectCornerTopLeft UIRectCornerTopRight UIRectCornerBottomLeft UIRectCornerBottomRight UIRectCornerAllCorners 12- 由角度转换弧度 #define DegreesToRadian(x) (M_PI * (x) / 180.0) 12- 由弧度转换角度 #define RadianToDegrees(radian) (radian*180.0)/(M_PI)12- 获取图片资源 //建议使用前两种宏定义,性能高于后者 #define LOADIMAGE(file,ext) [UIImage imageWithContentsOfFile:[[NSBundle mainBundle]pathForResource:file ofType:ext]] #define IMAGE(A) [UIImage imageWithContentsOfFile:[[NSBundle mainBundle] pathForResource:A ofType:nil]] #define ImageNamed(_pointer) [UIImage imageNamed:[UIUtil imageName:_pointer]] #define UIImageName(name) [UIImage imageNamed:name] 12- 文件路径 //获取temp #define PathTemp NSTemporaryDirectory() //获取Document #define PathDocument [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject] //获取 Cache #define PathCache [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) firstObject] 123- GCD代码只执行一次 #define kDISPATCH_ONCE_BLOCK(onceBlock) static dispatch_once_t onceToken;dispatch_once(&amp;onceToken, onceBlock);12- 自定义NSLog //DEBUG 模式下打印日志,当前行 #ifdef DEBUG define DLog(fmt, …) NSLog((@”%s [Line %d] “ fmt), PRETTY_FUNCTION, LINE, ##VA_ARGS);#else define DLog(…)#endif //重写NSLog,Debug模式下打印日志和当前行数 #if DEBUG #define NSLog(FORMAT, …) fprintf(stderr,”\\nfunction:%s line:%d content:%s\\n”, FUNCTION, LINE, [[NSString stringWithFormat:FORMAT, ##VA_ARGS] UTF8String]); #else #define NSLog(FORMAT, …) nil #endif //DEBUG 模式下打印日志,当前行 并弹出一个警告 #ifdef DEBUG define ULog(fmt, …) { UIAlertView *alert = [[UIAlertView alloc] initWithTitle:[NSString stringWithFormat:@”%s\\n [Line %d] “, PRETTY_FUNCTION, LINE] message:[NSString stringWithFormat:fmt, ##VA_ARGS] delegate:nil cancelButtonTitle:@”Ok” otherButtonTitles:nil]; [alert show]; }#else define ULog(…)#endif12- Font #define FONTS(size) [UIFont systemFontOfSize:(size)] #define BOLDFONTS(size) [UIFont boldSystemFontOfSize:(size)] 12- GCD //主线程 #define kDISPATCH_MAIN_THREAD(mainQueueBlock) dispatch_async(dispatch_get_main_queue(), mainQueueBlock); //异步线程 #define kDISPATCH_GLOBAL_QUEUE_DEFAULT(globalQueueBlock) dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), globalQueueBlocl); 12- 通知 #define NOTIF_ADD(n, f) [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(f) name:n object:nil] #define NOTIF_POST(n, o) [[NSNotificationCenter defaultCenter] postNotificationName:n object:o] #define NOTIF_REMV() [[NSNotificationCenter defaultCenter] removeObserver:self]12- Color // RGB颜色转换（16进制-&gt;10进制） #define UIColorFromRGB(rgbValue) [UIColor colorWithRed:((float)((rgbValue &amp; 0xFF0000) &gt;&gt; 16))/255.0 green:((float)((rgbValue &amp; 0xFF00) &gt;&gt; 8))/255.0 blue:((float)(rgbValue &amp; 0xFF))/255.0 alpha:1.0] // 获取RGB颜色 #define RGBA(r,g,b,a) [UIColor colorWithRed:r/255.0f green:g/255.0f blue:b/255.0f alpha:a] //清除背景色 #define CLEARCOLOR [UIColor clearColor] // 随机色 #define RandomCOLOR RGBCOLOR(arc4random_uniform(256),arc4random_uniform(256),arc4random_uniform(256)) 12- 获取window +(UIWindow)getWindow { UIWindow win = nil; //[UIApplication sharedApplication].keyWindow; for (id item in [UIApplication sharedApplication].windows) { if ([item class] == [UIWindow class]) { if (!((UIWindow*)item).hidden) { win = item; break; } } } return win;}12- 修改textField的placeholder的字体颜色、大小 [textField setValue:[UIColor redColor] forKeyPath:@”_placeholderLabel.textColor”];[textField setValue:[UIFont boldSystemFontOfSize:16] forKeyPath:@”_placeholderLabel.font”];// 或者textField.attributedPlaceholder = [[NSAttributedString alloc] initWithString:placeholder attributes:@{NSFontAttributeName : [UIFont systemFontOfSize:13],NSForegroundColorAttributeName : [UIColor grayColor]}]; 12- APP缓存 /* 存 数组数据/+(void)setObectOfArray:(NSArray )array fileName:(NSString *)fileName{ //缓存文件的 根路径 NSString *path = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) firstObject]; // 缓存 文件夹 路径 NSString *filePath = [path stringByAppendingPathComponent:@&quot;XXX.dataCache&quot;]; NSFileManager *fileManager = [NSFileManager defaultManager]; if ([fileManager fileExistsAtPath:filePath] == NO) { [fileManager createDirectoryAtPath:filePath withIntermediateDirectories:YES attributes:nil error:nil]; } //缓存文件的路径 NSString * cacheFilePath = [filePath stringByAppendingPathComponent:[NSString stringWithFormat:@&quot;%@.plist&quot;,fileName]]; BOOL isSuccess = [array writeToFile:cacheFilePath atomically:NO]; if (isSuccess) { NSLog(@&quot;缓存数据成功:---%@&quot;,cacheFilePath); }else { NSLog(@&quot;缓存数据失败:---%@&quot;,cacheFilePath); } } /** 取 数组数据/+(NSArray )cacheArrayForFileName:(NSString )fileName{ //缓存文件的 根路径 NSString *path = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) firstObject]; // 缓存 文件夹 路径 NSString *filePath = [path stringByAppendingPathComponent:@&quot;XXX.dataCache&quot;]; //缓存文件的路径 NSString * cacheFilePath = [filePath stringByAppendingPathComponent:[NSString stringWithFormat:@&quot;%@.plist&quot;,fileName]]; //取得缓存文件 NSArray *array = [NSArray arrayWithContentsOfFile:cacheFilePath]; return array; } /** 清除 这个全部的缓存数据 /+(void)clearCacheListData:(void (^)())completion{ // 异线程 dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ // 清楚缓存 //缓存文件的 根路径 NSString path = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) firstObject]; // 缓存 文件夹 路径 NSString filePath = [path stringByAppendingPathComponent:@”FortuneDonkey.dataCache”]; NSFileManager *manager = [NSFileManager defaultManager]; //移除文件夹 [manager removeItemAtPath:filePath error:nil]; // 创建一个新的文件夹 [manager createDirectoryAtPath:filePath withIntermediateDirectories:YES attributes:nil error:nil]; if (completion) { //回调主线程 dispatch_async(dispatch_get_main_queue(), ^{ completion(); }); } });} /** 清除SD缓存数据 /-(void)clearSDCacheData{ //先清除内存中的图片缓存 [[SDImageCache sharedImageCache] clearMemory]; //清除磁盘的缓存 [[SDImageCache sharedImageCache] clearDisk];} 12- 获取APP缓存大小 (CGFloat)getCachSize { NSUInteger imageCacheSize = [[SDImageCache sharedImageCache] getSize]; //获取自定义缓存大小 //用枚举器遍历 一个文件夹的内容 //1.获取 文件夹枚举器 NSString myCachePath = [NSHomeDirectory() stringByAppendingPathComponent:@”Library/Caches”]; NSDirectoryEnumerator enumerator = [[NSFileManager defaultManager] enumeratorAtPath:myCachePath]; __block NSUInteger count = 0; //2.遍历 for (NSString *fileName in enumerator) { NSString *path = [myCachePath stringByAppendingPathComponent:fileName]; NSDictionary *fileDict = [[NSFileManager defaultManager] attributesOfItemAtPath:path error:nil]; count += fileDict.fileSize;//自定义所有缓存大小 } // 得到是字节 转化为M CGFloat totalSize = ((CGFloat)imageCacheSize+count)/1024/1024; return totalSize;} 123- 几个常用权限判断 if ([CLLocationManager authorizationStatus] ==kCLAuthorizationStatusDenied) { NSLog(@&quot;没有定位权限&quot;); } AVAuthorizationStatus statusVideo = [AVCaptureDevice authorizationStatusForMediaType:AVMediaTypeVideo]; if (statusVideo == AVAuthorizationStatusDenied) { NSLog(@&quot;没有摄像头权限&quot;); } //是否有麦克风权限 AVAuthorizationStatus statusAudio = [AVCaptureDevice authorizationStatusForMediaType:AVMediaTypeAudio]; if (statusAudio == AVAuthorizationStatusDenied) { NSLog(@&quot;没有录音权限&quot;); } [PHPhotoLibrary requestAuthorization:^(PHAuthorizationStatus status) { if (status == PHAuthorizationStatusDenied) { NSLog(@&quot;没有相册权限&quot;); } }]; 12 - 系统相关的一些方法 //获取系统版本 #define IOS_VERSION [[[UIDevice currentDevice] systemVersion] floatValue] #define IS_IOS10_OR_LATER ([[[UIDevice currentDevice] systemVersion] floatValue] &gt;= 10.0) //获取当前语言 #define CurrentLanguage ([[NSLocale preferredLanguages] objectAtIndex:0]) //判断是否 Retina屏、设备是否%fhone 5、是否是iPad #define isRetina ([UIScreen instancesRespondToSelector:@selector(currentMode)] ? CGSizeEqualToSize(CGSizeMake(640, 960), [[UIScreen mainScreen] currentMode].size) : NO) #define iPhone5 ([UIScreen instancesRespondToSelector:@selector(currentMode)] ? CGSizeEqualToSize(CGSizeMake(640, 1136), [[UIScreen mainScreen] currentMode].size) : NO) #define iPhone6 ([UIScreen instancesRespondToSelector:@selector(currentMode)] ? CGSizeEqualToSize(CGSizeMake(750, 1334), [[UIScreen mainScreen] currentMode].size) : NO) #define isPad (UI_USER_INTERFACE_IDIOM() == UIUserInterfaceIdiomPad) //判断是真机还是模拟器 #if TARGET_OS_IPHONE//iPhone Device #endif #if TARGET_IPHONE_SIMULATOR//iPhone Simulator #endif12 - 长按复制功能 (void)viewDidLoad{ [self.view addGestureRecognizer:[[UILongPressGestureRecognizer alloc] initWithTarget:self action:@selector(pasteBoard:)]];} (void)pasteBoard:(UILongPressGestureRecognizer *)longPress { if (longPress.state == UIGestureRecognizerStateBegan) {UIPasteboard *pasteboard = [UIPasteboard generalPasteboard]; pasteboard.string = @&quot;我是文字&quot;; }} 123- 判断图片类型 //通过图片 Data 数据第一个字节 来获取图片扩展名 (NSString )contentTypeForImageData:(NSData )data{ uint8_t c; [data getBytes:&amp;c length:1]; switch (c) { case 0xFF: return @&quot;jpeg&quot;; case 0x89: return @&quot;png&quot;; case 0x47: return @&quot;gif&quot;; case 0x49: case 0x4D: return @&quot;tiff&quot;; case 0x52: if ([data length] &lt; 12) { return nil; } NSString *testString = [[NSString alloc] initWithData:[data subdataWithRange:NSMakeRange(0, 12)] encoding:NSASCIIStringEncoding]; if ([testString hasPrefix:@&quot;RIFF&quot;] &amp;&amp; [testString hasSuffix:@&quot;WEBP&quot;]) { return @&quot;webp&quot;; } return nil; } return nil;} 12- 获取手机和 APP 信息 //手机序列号NSString* identifierNumber = [[UIDevice currentDevice] uniqueIdentifier]; //手机别名： 用户定义的名称NSString* userPhoneName = [[UIDevice currentDevice] name]; //设备名称NSString* deviceName = [[UIDevice currentDevice] systemName]; //手机系统版本NSString* phoneVersion = [[UIDevice currentDevice] systemVersion]; //手机型号NSString* phoneModel = [[UIDevice currentDevice] model]; //地方型号 （国际化区域名称）NSString* localPhoneModel = [[UIDevice currentDevice] localizedModel]; NSDictionary infoDictionary = [[NSBundle mainBundle] infoDictionary];// 当前应用名称NSString appCurName = [infoDictionary objectForKey:@”CFBundleDisplayName”]; // 当前应用版本NSString *appCurVersion = [infoDictionary objectForKey:@”CFBundleShortVersionString”]; // 当前应用版本号码 int类型NSString *appCurVersionNum = [infoDictionary objectForKey:@”CFBundleVersion”]; 123 - UIImage绘制圆角 (UIImage )circleImage{ // NO代表透明 UIGraphicsBeginImageContextWithOptions(self.size, NO, 1); // 获得上下文 CGContextRef ctx = UIGraphicsGetCurrentContext(); // 添加一个圆 CGRect rect = CGRectMake(0, 0, self.size.width, self.size.height); // 方形变圆形 CGContextAddEllipseInRect(ctx, rect); // 裁剪 CGContextClip(ctx); // 将图片画上去 [self drawInRect:rect]; UIImage image = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return image;} 12- 准确获取图片像素 CGFloat fixelW = CGImageGetWidth(image.CGImage);CGFloat fixelH = CGImageGetHeight(image.CGImage);12- JSON字符串转字典 (NSDictionary )parseJSONStringToNSDictionary:(NSString )JSONString { NSData JSONData = [JSONString dataUsingEncoding:NSUTF8StringEncoding]; NSDictionary responseJSON = [NSJSONSerialization JSONObjectWithData:JSONData options:NSJSONReadingMutableLeaves error:nil]; return responseJSON;}123- 获取当前控制器 //获取当前屏幕显示的viewcontroller (UIViewController )getCurrentVC{ UIWindow window = [[UIApplication sharedApplication].windows firstObject]; if (!window) { return nil; } UIView tempView; for (UIView subview in window.subviews) { if ([[subview.classForCoder description] isEqualToString:@&quot;UILayoutContainerView&quot;]) { tempView = subview; break; } } if (!tempView) { tempView = [window.subviews lastObject]; } id nextResponder = [tempView nextResponder]; while (![nextResponder isKindOfClass:[UIViewController class]] || [nextResponder isKindOfClass:[UINavigationController class]] || [nextResponder isKindOfClass:[UITabBarController class]]) { tempView = [tempView.subviews firstObject]; if (!tempView) { return nil; } nextResponder = [tempView nextResponder]; } return (UIViewController *)nextResponder;} 12- KVO监听某个对象的属性 // 添加监听者[self addObserver:self forKeyPath:property options:NSKeyValueObservingOptionNew context:nil]; // 当监听的属性值变化的时候会来到这个方法 (void)observeValueForKeyPath:(NSString )keyPath ofObject:(id)object change:(NSDictionary )change context:(void *)context { if ([keyPath isEqualToString:@”property”]) {[self textViewTextChange]; } else { }}12- Reachability判断网络状态 NetworkStatus status = [[Reachability reachabilityForInternetConnection] currentReachabilityStatus]; if (status == NotReachable) { NSLog(@”当前设备无网络”); } if (status == ReachableViaWiFi) { NSLog(@”当前wifi网络”); } if (status == ReachableViaWWAN) { NSLog(@”当前蜂窝移动网络”); } 12- AFNetworking监听网络状态 // 监听网络状况 AFNetworkReachabilityManager *mgr = [AFNetworkReachabilityManager sharedManager]; [mgr setReachabilityStatusChangeBlock:^(AFNetworkReachabilityStatus status) { switch (status) { case AFNetworkReachabilityStatusUnknown: break; case AFNetworkReachabilityStatusNotReachable: { NSLog(@”当前设备无网络”); } break; case AFNetworkReachabilityStatusReachableViaWiFi: NSLog(@”当前wifi网络”); break; case AFNetworkReachabilityStatusReachableViaWWAN: NSLog(@”当前蜂窝移动网络”); break; default: break; } }]; [mgr startMonitoring]; 12 - 父视图透明不影响子视图的做法 self.view.backgroundColor = [[UIColor whiteColor]colorWithAlphaComponent:0.7f];12- 取图片某一点的颜色 if (point.x &lt; 0 || point.y &lt; 0) return nil; CGImageRef imageRef = self.CGImage; NSUInteger width = CGImageGetWidth(imageRef); NSUInteger height = CGImageGetHeight(imageRef); if (point.x &gt;= width || point.y &gt;= height) return nil; unsigned char *rawData = malloc(height * width * 4); if (!rawData) return nil; CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB(); NSUInteger bytesPerPixel = 4; NSUInteger bytesPerRow = bytesPerPixel * width; NSUInteger bitsPerComponent = 8; CGContextRef context = CGBitmapContextCreate(rawData, width, height, bitsPerComponent, bytesPerRow, colorSpace, kCGImageAlphaPremultipliedLast | kCGBitmapByteOrder32Big); if (!context) { free(rawData); return nil; } CGColorSpaceRelease(colorSpace); CGContextDrawImage(context, CGRectMake(0, 0, width, height), imageRef); CGContextRelease(context); int byteIndex = (bytesPerRow * point.y) + point.x * bytesPerPixel; CGFloat red = (rawData[byteIndex] * 1.0) / 255.0; CGFloat green = (rawData[byteIndex + 1] * 1.0) / 255.0; CGFloat blue = (rawData[byteIndex + 2] * 1.0) / 255.0; CGFloat alpha = (rawData[byteIndex + 3] * 1.0) / 255.0; UIColor *result = nil; result = [UIColor colorWithRed:red green:green blue:blue alpha:alpha]; free(rawData); return result; 12 - 判断该图片是否有透明度通道 (BOOL)hasAlphaChannel{CGImageAlphaInfo alpha = CGImageGetAlphaInfo(self.CGImage);return (alpha == kCGImageAlphaFirst ||alpha == kCGImageAlphaLast || alpha == kCGImageAlphaPremultipliedFirst || alpha == kCGImageAlphaPremultipliedLast); }12- 两张图片合成 (UIImage)mergeImage:(UIImage)firstImage withImage:(UIImage)secondImage { CGImageRef firstImageRef = firstImage.CGImage; CGFloat firstWidth = CGImageGetWidth(firstImageRef); CGFloat firstHeight = CGImageGetHeight(firstImageRef); CGImageRef secondImageRef = secondImage.CGImage; CGFloat secondWidth = CGImageGetWidth(secondImageRef); CGFloat secondHeight = CGImageGetHeight(secondImageRef); CGSize mergedSize = CGSizeMake(MAX(firstWidth, secondWidth), MAX(firstHeight, secondHeight)); UIGraphicsBeginImageContext(mergedSize); [firstImage drawInRect:CGRectMake(0, 0, firstWidth, firstHeight)]; [secondImage drawInRect:CGRectMake(0, 0, secondWidth, secondHeight)]; UIImage image = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return image;} 123- 制作水印 // 画水印 (void) setImage:(UIImage )image withWaterMark:(UIImage )mark inRect:(CGRect)rect{ if ([[[UIDevice currentDevice] systemVersion] floatValue] &gt;= 4.0) {UIGraphicsBeginImageContextWithOptions(self.frame.size, NO, 0.0); } //原图 [image drawInRect:self.bounds]; //水印图 [mark drawInRect:rect]; UIImage *newPic = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); self.image = newPic;} 12- 让label的文字内容显示在左上／右上／左下／右下／中心顶／中心底部 自定义UILabel// 重写label的textRectForBounds方法 (CGRect)textRectForBounds:(CGRect)bounds limitedToNumberOfLines:(NSInteger)numberOfLines { CGRect rect = [super textRectForBounds:bounds limitedToNumberOfLines:numberOfLines]; switch (self.textAlignmentType) { case WZBTextAlignmentTypeLeftTop: { rect.origin = bounds.origin; } break; case WZBTextAlignmentTypeRightTop: { rect.origin = CGPointMake(CGRectGetMaxX(bounds) - rect.size.width, bounds.origin.y); } break; case WZBTextAlignmentTypeLeftBottom: { rect.origin = CGPointMake(bounds.origin.x, CGRectGetMaxY(bounds) - rect.size.height); } break; case WZBTextAlignmentTypeRightBottom: { rect.origin = CGPointMake(CGRectGetMaxX(bounds) - rect.size.width, CGRectGetMaxY(bounds) - rect.size.height); } break; case WZBTextAlignmentTypeTopCenter: { rect.origin = CGPointMake((CGRectGetWidth(bounds) - CGRectGetWidth(rect)) / 2, CGRectGetMaxY(bounds) - rect.origin.y); } break; case WZBTextAlignmentTypeBottomCenter: { rect.origin = CGPointMake((CGRectGetWidth(bounds) - CGRectGetWidth(rect)) / 2, CGRectGetMaxY(bounds) - CGRectGetMaxY(bounds) - rect.size.height); } break; case WZBTextAlignmentTypeLeft: { rect.origin = CGPointMake(0, rect.origin.y); } break; case WZBTextAlignmentTypeRight: { rect.origin = CGPointMake(rect.origin.x, 0); } break; case WZBTextAlignmentTypeCenter: { rect.origin = CGPointMake((CGRectGetWidth(bounds) - CGRectGetWidth(rect)) / 2, (CGRectGetHeight(bounds) - CGRectGetHeight(rect)) / 2); } break; default: break; } return rect;} (void)drawTextInRect:(CGRect)rect { CGRect textRect = [self textRectForBounds:rect limitedToNumberOfLines:self.numberOfLines]; [super drawTextInRect:textRect];} 12- 移除字符串中的空格和换行 (NSString )removeSpaceAndNewline:(NSString )str { NSString *temp = [str stringByReplacingOccurrencesOfString:@” “ withString:@””]; temp = [temp stringByReplacingOccurrencesOfString:@”\\r” withString:@””]; temp = [temp stringByReplacingOccurrencesOfString:@”\\n” withString:@””]; return temp;} 12- 判断字符串中是否有空格 (BOOL)isBlank:(NSString *)str { NSRange _range = [str rangeOfString:@” “]; if (_range.location != NSNotFound) { //有空格 return YES; } else { //没有空格 return NO; }} 12- 获取一个视频的第一帧图片 NSURL url = [NSURL URLWithString:filepath];AVURLAsset asset1 = [[AVURLAsset alloc] initWithURL:url options:nil];AVAssetImageGenerator generate1 = [[AVAssetImageGenerator alloc] initWithAsset:asset1];generate1.appliesPreferredTrackTransform = YES;NSError err = NULL;CMTime time = CMTimeMake(1, 2);CGImageRef oneRef = [generate1 copyCGImageAtTime:time actualTime:NULL error:&amp;err];UIImage *one = [[UIImage alloc] initWithCGImage:oneRef]; return one;123 - 获取视频的时长 (NSInteger)getVideoTimeByUrlString:(NSString )urlString { NSURL videoUrl = [NSURL URLWithString:urlString]; AVURLAsset *avUrl = [AVURLAsset assetWithURL:videoUrl]; CMTime time = [avUrl duration]; int seconds = ceil(time.value/time.timescale); return seconds;}123- 当tableView占不满一屏时，去除下边多余的单元格 self.tableView.tableHeaderView = [UIView new];self.tableView.tableFooterView = [UIView new];12- isKindOfClass和isMemberOfClass的区别 isKindOfClass可以判断某个对象是否属于某个类，或者这个类的子类。isMemberOfClass更加精准，它只能判断这个对象类型是否为这个类(不能判断子类)123- 禁用系统滑动返回功能 (void)viewDidAppear:(BOOL)animated{ [super viewDidAppear:animated]; if ([self.navigationController respondsToSelector:@selector(interactivePopGestureRecognizer)]) {self.navigationController.interactivePopGestureRecognizer.delegate = self; }} (void)viewWillDisappear:(BOOL)animated { [super viewWillDisappear:animated]; if ([self.navigationController respondsToSelector:@selector(interactivePopGestureRecognizer)]) {self.navigationController.interactivePopGestureRecognizer.delegate = nil; }} (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer{ return NO;}12- UILabel设置内边距 子类化UILabel，重写drawTextInRect方法 (void)drawTextInRect:(CGRect)rect { // 边距，上左下右 UIEdgeInsets insets = {0, 5, 0, 5}; [super drawTextInRect:UIEdgeInsetsInsetRect(rect, insets)];} 12- UILabel设置文字描边 子类化UILabel，重写drawTextInRect方法 (void)drawTextInRect:(CGRect)rect{ CGContextRef c = UIGraphicsGetCurrentContext(); // 设置描边宽度 CGContextSetLineWidth(c, 1); CGContextSetLineJoin(c, kCGLineJoinRound); CGContextSetTextDrawingMode(c, kCGTextStroke); // 描边颜色 self.textColor = [UIColor redColor]; [super drawTextInRect:rect]; // 文本颜色 self.textColor = [UIColor yellowColor]; CGContextSetTextDrawingMode(c, kCGTextFill); [super drawTextInRect:rect];} 12- UIView背景颜色渐变 (CAGradientLayer )setGradualChangingColor:(UIView )view fromColor:(NSString )fromHexColorStr toColor:(NSString )toHexColorStr{ // CAGradientLayer类对其绘制渐变背景颜色、填充层的形状(包括圆角) CAGradientLayer *gradientLayer = [CAGradientLayer layer]; gradientLayer.frame = view.bounds; // 创建渐变色数组，需要转换为CGColor颜色 gradientLayer.colors = @[(bridge id)[UIColor colorWithHexString:fromHexColorStr].CGColor,(bridge id)[UIColor colorWithHexString:toHexColorStr].CGColor]; // 设置渐变颜色方向，左下点为(0,0), 右上点为(1,1) gradientLayer.startPoint = CGPointMake(0, 0.5); gradientLayer.endPoint = CGPointMake(1, 0.5); // 设置颜色变化点，取值范围 0.0~1.0 gradientLayer.locations = @[@0,@1]; return gradientLayer;} 12- UIView某个角添加圆角 // 左上角和右下角添加圆角UIBezierPath maskPath = [UIBezierPath bezierPathWithRoundedRect:view.bounds byRoundingCorners:(UIRectCornerTopLeft | UIRectCornerBottomRight) cornerRadii:CGSizeMake(20, 20)];CAShapeLayer maskLayer = [CAShapeLayer layer];maskLayer.frame = view.bounds;maskLayer.path = maskPath.CGPath;view.layer.mask = maskLayer;12- UIImage和base64互转 // view分类方法 (NSString )encodeToBase64String:(UIImage )image {return [UIImagePNGRepresentation(image) base64EncodedStringWithOptions:NSDataBase64Encoding64CharacterLineLength];} (UIImage )decodeBase64ToImage:(NSString )strEncodeData {NSData *data = [[NSData alloc]initWithBase64EncodedString:strEncodeData options:NSDataBase64DecodingIgnoreUnknownCharacters];return [UIImage imageWithData:data];} 12- UIWebView设置背景透明 [webView setBackgroundColor:[UIColor clearColor]];[webView setOpaque:NO];12- 设置tableView分割线颜色以及顶到头 // 分割线颜色[self.tableView setSeparatorColor:[UIColor myColor]]; // 顶到头 (void)tableView:(UITableView )tableView willDisplayCell:(UITableViewCell )cell forRowAtIndexPath:(NSIndexPath *)indexPath { [cell setSeparatorInset:UIEdgeInsetsZero]; [cell setLayoutMargins:UIEdgeInsetsZero]; cell.preservesSuperviewLayoutMargins = NO;} (void)viewDidLayoutSubviews { [self.tableView setSeparatorInset:UIEdgeInsetsZero]; [self.tableView setLayoutMargins:UIEdgeInsetsZero];} 12- 为一个view添加虚线边框 CAShapeLayer *border = [CAShapeLayer layer]; border.strokeColor = [UIColor colorWithRed:67/255.0f green:37/255.0f blue:83/255.0f alpha:1].CGColor; border.fillColor = nil; border.lineDashPattern = @[@4, @2]; border.path = [UIBezierPath bezierPathWithRect:view.bounds].CGPath; border.frame = view.bounds; [view.layer addSublayer:border];12 - UITextView中打开或禁用复制，剪切，选择，全选等功能 // 继承UITextView重写这个方法 (BOOL)canPerformAction:(SEL)action withSender:(id)sender{// 返回NO为禁用，YES为开启 // 粘贴 if (action == @selector(paste:)) return NO; // 剪切 if (action == @selector(cut:)) return NO; // 复制 if (action == @selector(copy:)) return NO; // 选择 if (action == @selector(select:)) return NO; // 选中全部 if (action == @selector(selectAll:)) return NO; // 删除 if (action == @selector(delete:)) return NO; // 分享 if (action == @selector(share)) return NO; return [super canPerformAction:action withSender:sender];} `","categories":[],"tags":[]},{"title":"Jenkins + GitLab + Xcode + Fir 实现iOS自动打包和分发","slug":"Jenkins-GitLab-Xcode-Fir-实现iOS自动打包和分发","date":"2018-07-09T10:45:14.000Z","updated":"2018-07-09T10:59:16.630Z","comments":true,"path":"2018/07/09/Jenkins-GitLab-Xcode-Fir-实现iOS自动打包和分发/","link":"","permalink":"http://yoursite.com/2018/07/09/Jenkins-GitLab-Xcode-Fir-实现iOS自动打包和分发/","excerpt":"一、简述Jenkins是一个广泛用于持续构建的可视化web工具，持续构建即各种项目的”自动化”编译、打包、分发部署。jenkins可以很好的支持各种语言（比如：java, c#, php等）的项目构建，也完全兼容ant、maven、gradle等多种第三方构建工具，同时跟svn、git能无缝集成，也支持直接与知名源代码托管网站，比如github、bitbucket直接集成。 二、Jenkins的安装1、Jenkins本身是用java语言开发的，所以安装Jenkins之前，要保证你的电脑有jdk，如果没有，可到如下链接下载安装：http://www.oracle.com/technetwork/java/javase/downloads/index.html","text":"一、简述Jenkins是一个广泛用于持续构建的可视化web工具，持续构建即各种项目的”自动化”编译、打包、分发部署。jenkins可以很好的支持各种语言（比如：java, c#, php等）的项目构建，也完全兼容ant、maven、gradle等多种第三方构建工具，同时跟svn、git能无缝集成，也支持直接与知名源代码托管网站，比如github、bitbucket直接集成。 二、Jenkins的安装1、Jenkins本身是用java语言开发的，所以安装Jenkins之前，要保证你的电脑有jdk，如果没有，可到如下链接下载安装：http://www.oracle.com/technetwork/java/javase/downloads/index.html 2、进入Jenkins的官网 http://jenkins-ci.org/ ，选择Mac 直接安装。安装成功后。访问http://localhost 是否可正常访问. 3、安装完成后，会直接跳转到如下界面，如果没有跳转或者跳转失败，可通过执行如下命令 ” open /Applications/Jenkins/jenkins.war ” 进入到该界面： 4、按照提示，找到/Users/Shared/Jenkins/Home/ 这个目录下，这个目录虽然是共享目录，但是有权限的，非Jenkins用户/secrets/目录是没有读写权限的。 5、修改权限打开initialAdminPassword文件，复制出密码，就可以填到网页上去重置密码了。如下图 6、安装插件，插件安装完成后，可能会卡在如下界面，不会自动跳转，刷新下界面即可： 7、在刷新后的界面中注册，输入用户名和密码，如下： 三、Jenkins的使用1、由于安装过程中，有些插件可能会安装失败，通过如下方式检查所需的插件是否安装成功。通过“系统管理-&gt;管理插件-&gt;已安装“，检查如下所需的插件是否安装成功： Xcode integration (Xcode插件) Credentials Plugin (签名证书管理插件) Keychains and Provisioning Profiles Management (签名证书管理插件) GitLab Plugin Gitlab Hook Plugin Post-Build Script Plug-in Email Extension Plugin 2、构建项目 点击新建好的项目，进来配置一下General参数。 接着设置源码管理。 由于现在用到的是GitLab，先配置SSH Key，在Jenkins的证书管理中添加SSH。在Jenkins管理页面，选择“Credentials”，然后选择“Global credentials (unrestricted)”，点击“Add Credentials”，如下图所示，我们填写自己的SSH信息，然后点击“Save”，这样就把SSH添加到Jenkins的全局域中去了。 重点！！重点！！ 构建环境设置iOS打包需要签名文件和证书，所以这部分我们勾选“Keychains and Code Signing Identities”和“Mobile Provisioning Profiles”。这里我们又需要用到Jenkins的插件，在系统管理页面，选择“Keychains and Provisioning Profiles Management”。 点击choose File 并上传login.keychain 地址： /Users/管理员用户名/Library/keychains/login.keychain. 上传成功后会出现: 点击Add Code Signing Identity添加对应的签名 3.上传Provisioning Profiles文件，xcode的profile存放在~/Library/MobileDevice/Provisioning Profiles/中 4、在系统管理-&gt;系统设置-&gt;Xcode Builder 中设置相关证书 五、回到项目配置-&gt;构建 六、构建成功后使用fir上传 关于fir token 的获取，可以登录fir,进入个人中心生成token 构建返回项目首页，点击构建即可自动化打包上传 如果构建失败，可以在构建项的Console Output中查看构建信息","categories":[],"tags":[]},{"title":"配置多个SSH Key","slug":"配置多个SSH-Key","date":"2018-07-06T12:15:16.000Z","updated":"2018-07-22T15:59:56.603Z","comments":true,"path":"2018/07/06/配置多个SSH-Key/","link":"","permalink":"http://yoursite.com/2018/07/06/配置多个SSH-Key/","excerpt":"大家在工作中经常会碰到需要使用个人的Github以及公司的Gitlab这样的一种情况，这时我们就需要配置不同的SSH Key了。具体步骤如下： 1、打开终端，切换到系统的SSH目录下 12cd ~/.ssh 2、生成自己Github的SSH Key 12ssh-keygen -t rsa -C &quot;Github账号&quot; -f github_rsa","text":"大家在工作中经常会碰到需要使用个人的Github以及公司的Gitlab这样的一种情况，这时我们就需要配置不同的SSH Key了。具体步骤如下： 1、打开终端，切换到系统的SSH目录下 12cd ~/.ssh 2、生成自己Github的SSH Key 12ssh-keygen -t rsa -C &quot;Github账号&quot; -f github_rsa 3、输入Github账号密码 4、Github SSH 公钥获取 12cat ~/.ssh/id_rsa.pub 5、生成公司Gitlab的SSH Key 12ssh-keygen -t rsa -C &quot;Gitlab账号&quot; -f company_rsa 6、公司 SSH 公钥获取 12cat ~/.ssh/id_rsa.pub 8、添加配置文件 config (如果有则直接编辑，没有则创建，路径~/.ssh/config)，配置写法如下： 123456789101112# githubHost githubHostName github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/github_rsa# gitlabHost gitlabHostName gitlab.company.comPreferredAuthentications publickeyIdentityFile ~/.ssh/company_rsa Host 名称可以随便设置， HostName 就是网站的地址 这里要注意的一点是，例如公司Gitlab主机地址是http://10.10.10.89:11000，那么HostName就是 10.10.10.89 9、测试是否添加成功 123456789# 测试GitHub# 就是刚刚你给Host取的名字ssh -T git@github# 测试GitLabssh -T git@gitlab 10、不同项目切换不同的ssh1234567取消全局 用户名/邮箱设置，并进入项目文件夹单独设置git config –global –unset user.namegit config –global –unset user.email# 单独设置每个repo 用户名/邮箱git config user.email “xxxx@xx.com”git config user.name “xxxx”","categories":[],"tags":[]},{"title":"Mac下安装Windows虚拟机","slug":"Mac下安装Windows虚拟机","date":"2018-07-05T12:05:32.000Z","updated":"2018-07-06T12:02:31.851Z","comments":true,"path":"2018/07/05/Mac下安装Windows虚拟机/","link":"","permalink":"http://yoursite.com/2018/07/05/Mac下安装Windows虚拟机/","excerpt":"说起虚拟机软件，除了比较常用的 VMWare Workstation / Player 和 Parallels Desktop 等商业软件外，还有一款相当强大且开源免费跨平台的虚拟机软件——它就是 VirtualBox。 VirtualBox 完全免费开源，可跨平台运行在 Win、Mac、Linux 系统上。加上该虚拟机功能强大且性能出色，可以流畅虚拟运行各大主流操作系统，如微软全系列 (包括 Windows 10) / Linux 各种发行版 (Ubuntu / CentOS / Deepin ) 甚至是 Android 等，能应对各种场景需求。因此它一直是无数用户首选的虚拟机软件……","text":"说起虚拟机软件，除了比较常用的 VMWare Workstation / Player 和 Parallels Desktop 等商业软件外，还有一款相当强大且开源免费跨平台的虚拟机软件——它就是 VirtualBox。 VirtualBox 完全免费开源，可跨平台运行在 Win、Mac、Linux 系统上。加上该虚拟机功能强大且性能出色，可以流畅虚拟运行各大主流操作系统，如微软全系列 (包括 Windows 10) / Linux 各种发行版 (Ubuntu / CentOS / Deepin ) 甚至是 Android 等，能应对各种场景需求。因此它一直是无数用户首选的虚拟机软件…… 一、准备工具 VirtualBox虚拟机下载：https://www.virtualbox.org/wiki/Downloads windows7 32位纯净版下载地址：http://www.xitongtiandi.com/Windows7/148.htmlps:下载太慢？等着快睡着？没事，给大家分享一个利器，Mac迅雷破解版 https://pan.baidu.com/s/1dGMeCH7 提取码 rm9i 二、安装VirtualBox 一路傻瓜式安装。。。 三、新建虚拟机接下来按照图片一步步来即可，注意标红部分 内存可分配大些 同样，这里分配虚拟硬盘大小时，直接设为最大，如果设置过小，安装时会失败。 四、安装Windows 7 点击红色划线地方，选择下载好的win7镜像，设定之后，点击启动，进入到安装页面 第一次进入可能会卡死，直接退出重启就好 选择启动PE光盘系统，双击自动换分硬盘为4个1区，按照步骤一路安装即可。 重启后完成安装 五、安装VirtualBox Guest AdditionsWindows7安装完成后，已经可以正常使用，但是此时会有很多不便，比如拖动虚拟机窗口会导致系统两边留空白，需要快捷键（command）才能实现Mac和win7系统切换等等。这时可以通过安装VirtualBox Guest Additions改善这些状况，它包含了可优化操作系统以实现更佳性能和可用性的设备驱动程序和系统应用程序。 安装方法：点击虚拟机系统窗口 -&gt; Devices -&gt; Insert Guest Addtions CD Image，回到win7桌面，打开计算机，则会看到多了个CD驱动器 点开驱动器，选择VirtualBox Guest Additions进行安装，默认点下一步，中间会弹出要安装其他程序窗口，全部选择安装，直至安装成功 至此，VirtualBox Guest Additions安装完成，重启电脑，你就会发现之前的不便完全木有了。。。","categories":[],"tags":[]},{"title":"Git 使用规范","slug":"app","date":"2018-07-05T09:53:00.000Z","updated":"2018-07-06T12:02:21.101Z","comments":true,"path":"2018/07/05/app/","link":"","permalink":"http://yoursite.com/2018/07/05/app/","excerpt":"Why？在团队协作中我们经常碰到的问题是每个人都有自己的开发习惯，这个习惯包含但不限于编码风格，工具使用等，所以往往协作中就会出现各种各样的问题。目前来说，我们仅仅使用了 Git 的些许功能，我们并没有规范化。这样随着项目开发的时间越长，导致项目中 Git 使用越混乱。 Git 版本规范","text":"Why？在团队协作中我们经常碰到的问题是每个人都有自己的开发习惯，这个习惯包含但不限于编码风格，工具使用等，所以往往协作中就会出现各种各样的问题。目前来说，我们仅仅使用了 Git 的些许功能，我们并没有规范化。这样随着项目开发的时间越长，导致项目中 Git 使用越混乱。 Git 版本规范 分支 master 分支为主分支(保护分支)，不能直接在 master 上进行修改代码和提交； develop 分支为测试分支，所以开发完成需要提交测试的功能合并到该分支； feature 分支为开发分支，大家根据不同需求创建独立的功能分支，开发完成后合并到 develop 分支； 例如，M 开发用户模块，那么 M 创建一个 feature/user 分支（基于 develop 分支） ，开发完成后，合并到 develop 分支； fix 分支为 bug 修复分支，需要根据实际情况对已发布的版本进行漏洞修复； Tag采用三段式，V 版本.里程碑.序号，如 V1.2.1，2可能代表当前项目属于几期 架构升级或架构重大调整，修改第2位 新功能上线或者模块大的调整，修改第2位 bug修复上线，修改第3位具体操作，可参考 Git标签 Commit 规范Commit 的前提是，所负责的模块完成并通过基本测试，运行无误后才能提交。Commit message 信息格式采用目前主流的 Angular 规范，这是目前使用最广的写法，比较合理和系统化。 在项目开发开发中或许我们能经常看到如下的一些 commit 情形： commit message 写的很简单，根本没有办法从 message 中获知该 commit 用意的 commit message 写的很随意，message 和变更代码之间不能建立联系的 commit message 写的过于冗余 commit message 不填 一旦涉及代码回滚，issue 回溯，changelog，语义化版本发布等操作时，不熟悉的人直接瞬间懵逼掉。为了解决这些问题，我们需要对 Commit message 进行规范化约束 Commit message 格式说明Commit message 一般包括三部分：Header、Body 和 Footer。 Header type：用于说明 commit 的类别，规定为如下几种 feat：新增功能 fix：修复 bug docs：修改文档 refactor：代码重构，未新增任何功能和修复任何 bug build：改变构建流程，新增依赖库、工具等（例如 webpack 修改） style：仅仅修改了空格、缩进等，不改变代码逻辑 perf：优化相关，比如提升性能、体验 chore：非 src 和 test 的修改 test：测试用例，包括单元测试、集成测试等 revert：回滚到上一个版本 Body 对本次 commit 的详细描述，可分多行 Footer 不兼容变动：需要描述相关信息 关闭指定Issue：输入 Issue 信息","categories":[],"tags":[]},{"title":"iOS APP内跳转到系统相册（包含其它APP间跳转）","slug":"iOS APP内跳转到系统相册（包含其它APP间跳转）","date":"2017-12-30T16:00:00.000Z","updated":"2018-09-08T03:47:17.477Z","comments":true,"path":"2017/12/31/iOS APP内跳转到系统相册（包含其它APP间跳转）/","link":"","permalink":"http://yoursite.com/2017/12/31/iOS APP内跳转到系统相册（包含其它APP间跳转）/","excerpt":"APP间的跳转主要通过UIApplication.shared.openURL(url)]这种方法来实现的，但iOS10后又稍加不同。 1234567891011121314let urlStr = &quot;weixin://&quot; if let url = URL(string:urlStr) &#123; if #available(iOS 10.0, *) &#123; UIApplication.shared.open(url, options: Dictionary(), completionHandler: nil) &#125; else &#123; UIApplication.shared.openURL(url) &#125;","text":"APP间的跳转主要通过UIApplication.shared.openURL(url)]这种方法来实现的，但iOS10后又稍加不同。 1234567891011121314let urlStr = &quot;weixin://&quot; if let url = URL(string:urlStr) &#123; if #available(iOS 10.0, *) &#123; UIApplication.shared.open(url, options: Dictionary(), completionHandler: nil) &#125; else &#123; UIApplication.shared.openURL(url) &#125; 跳转系统内相册应用可以通过 UIApplication.shared.openURL(“photos-redirect://“)来实现，但是审核时会被当成使用私有API处理，所以我们需要做混淆处理。 123456789101112131415//跳转let urlStr = self.decode(&quot;cGhvdG9zLXJlZGlyZWN0Oi8v&quot;) if let url = URL(string:urlStr) &#123; if #available(iOS 10.0, *) &#123; UIApplication.shared.open(url, options: Dictionary(), completionHandler: nil) &#125; else &#123; UIApplication.shared.openURL(url) &#125; 为通过审核，对 “photos-redirect://“ 进行base64编码混淆后再解码 1234567891011//base64解码 func decode(_ string: String) -&gt; String &#123; let data = Data(base64Encoded: string, options: []) let decodedStr = String(data: data ?? Data(), encoding: .utf8) return decodedStr ?? &quot;&quot; &#125; 附上其它 URL Scheme 要打开的APP URL Scheme 打10086 tel://10086 App Store itms-apps:// Safari http://muhlenxi.com/ Maps maps:// 备忘录 mobilenotes:// SMS sms:// Mail mailto:// iBooks ibooks:// Music music:// Videos videos:// QQ mqq:// 微信 weixin:// 淘宝 taobao:// 点评 dianping:// dianping://search 微博 sinaweibo:// 名片全能王 camcard:// 支付宝 alipay:// 豆瓣fm doubanradio:// 京东 openapp.jdmoble:// 人人 renren:// 知乎 zhihu:// 优酷 youku://","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]}]}